package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"sync/atomic"
	"time"
)

var (
	listenAddr    string
	outputDir     string
	maxFiles      int
	verbose       bool
	requestCount  int32
	pauseDuration time.Duration
)

func init() {
	// Set up CLI arguments
	flag.StringVar(&listenAddr, "listen", ":8080", "HTTP server listen address")
	flag.StringVar(&outputDir, "output", "/var/lib/nagios4/spool/checkresults", "Directory to save XML files")
	flag.IntVar(&maxFiles, "max-files", 1000, "Maximum number of files allowed in the output directory before pausing")
	flag.BoolVar(&verbose, "verbose", false, "Enable verbose logging")
	flag.DurationVar(&pauseDuration, "pause", 10*time.Second, "Pause duration when max files exceeded")
	flag.Parse()
}

func main() {
	// Ensure the output directory exists and is writable
	if err := checkOutputDir(outputDir); err != nil {
		log.Fatalf("Failed to validate output directory: %v", err)
	}

	http.HandleFunc("/", handleRequest)
	log.Printf("Starting server on %s...", listenAddr)
	if err := http.ListenAndServe(listenAddr, nil); err != nil {
		log.Fatalf("Server failed: %v", err)
	}
}

func checkOutputDir(dir string) error {
	info, err := os.Stat(dir)
	if os.IsNotExist(err) {
		return fmt.Errorf("directory does not exist: %s", dir)
	}
	if !info.IsDir() {
		return fmt.Errorf("not a directory: %s", dir)
	}
	if err := ioutil.WriteFile(filepath.Join(dir, ".check"), []byte{}, 0644); err != nil {
		return fmt.Errorf("directory is not writable: %s", dir)
	}
	os.Remove(filepath.Join(dir, ".check"))
	return nil
}

func handleRequest(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		log.Printf("Invalid request method: %s", r.Method)
		http.Error(w, "Invalid request method", http.StatusMethodNotAllowed)
		return
	}

	// Parse the form data
	err := r.ParseForm()
	if err != nil {
		log.Printf("Failed to parse form data: %v", err)
		http.Error(w, "Failed to parse form data", http.StatusBadRequest)
		return
	}

	// Extract the XML data from the form
	xmlData := r.FormValue("XMLDATA")
	if xmlData == "" {
		log.Println("Missing XMLDATA in request")
		http.Error(w, "Missing XMLDATA in request", http.StatusBadRequest)
		return
	}

	// Log the raw XML data for debugging purposes
	log.Printf("Raw XMLDATA: %s", xmlData)

	// Check if the file count exceeds maxFiles, and pause if necessary
	for {
		if shouldPause() {
			if verbose {
				log.Printf("Max files reached. Pausing for %v...", pauseDuration)
			}
			time.Sleep(pauseDuration)
		} else {
			break
		}
	}

	// Write the XML to a new file
	filename := fmt.Sprintf("checkresult_%d.xml", atomic.AddInt32(&requestCount, 1))
	filePath := filepath.Join(outputDir, filename)
	if err := ioutil.WriteFile(filePath, []byte(xmlData), 0644); err != nil {
		log.Printf("Failed to write file %s: %v", filePath, err)
		http.Error(w, "Failed to write file", http.StatusInternalServerError)
		return
	}

	if verbose {
		log.Printf("Saved XML to %s", filePath)
	}

	w.WriteHeader(http.StatusOK)
}

func shouldPause() bool {
	files, err := ioutil.ReadDir(outputDir)
	if err != nil {
		log.Printf("Failed to read output directory: %v", err)
		return false
	}
	return len(files) >= maxFiles
}
